## 索引优化

#### 联合索引（a、b、c）

##### 1.联合索引第一个字段使用范围时，不会走索引

- 若a使用范围，bc使用常量，不会走索引
- 若a常量，b范围，不管c是什么，只走ab索引

结论：虽然扫描范围比全表扫描小，但回表效率不如scan全表扫描（该效率决定最终扫描方式）

##### 2.强制走索引

- 可以使用force index强制使用索引，但效率依然不如scan

##### 3.覆盖索引优化

##### 4.in和or在表数据量比较大的情况会走索引（排序时一定不会走索引），在表记录不多的情况下会选择全表扫描

##### 5.like xx%一般情况下都会走索引

- > 什么是索引下推了？ 对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，SELECT * FROM employees WHERE name like 'LiLei%' AND age = 22 AND position ='manager' 这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和 position是无序的，无法很好的利用索引。 在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 'LiLei' 开头的索引，然后拿这些索引对应的主键逐个回表，到主键索 引上找出相应的记录，再比对age和position这两个字段的值是否符合。 MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可 以有效的减少回表次数。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 'LiLei' 开头的索引之后，同时还会在索引里过 滤age和position这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据



