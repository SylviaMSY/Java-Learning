## MySQL的锁

#### 1 锁的分类

1. **表锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

2. 页面锁：其性质介于表锁行锁之间，会出现死锁

3. **行锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高

4. 间隙锁：范围查询时，范围区间内但不存在的记录，会被加锁，防止幻读，容易阻塞。

5. 全局锁：对整个数据库实例加锁，常用在做全库逻辑备份、主从复制

   ``` sql
   FLUSH TABLES WRITE READ LOCK --客户端异常断开时，会自动恢复正常状态
   set global readonly=true --不建议使用（readonly可能被用来做其他逻辑；客户端异常时，不能主动释放锁定状态）
   ```

#### 2 锁的性质

1. 共享锁-S锁（读锁）
2. 排他锁-X锁（写锁）

#### 3 不同引擎锁的使用

**MyISAM：表锁**

- 读写、写写操作都是串行执行
- 并发锁concurrent_insert=0、1、2：可设置表尾插入
- 锁调度：优先写锁（可通过设置改变优先级）

**InnoDB锁：行锁、支持事务**

- 事务
  - ACID属性：原子性、一致性、隔离性、持久性
  - 并发问题：更新丢失、脏读、不可重复读、幻读（有新数据）
  - 隔离级别：read uncommitted未提交读、read committed提交读、repeatable read可重读（有幻读风险，通过MVCC解决）、serializable可串行化（强制排序，解决幻读问题）
- 行锁
  - 类型：S锁、X锁、IS锁、IX锁
  - 实现方式：通过索引上的索引项来实现（所以使用索引时才是行锁，否则升级为表锁）
- 事务中的行锁：两阶段锁
  - commit之后才会释放行锁：所以尽量将并发度高的操作放在最后，减少锁定时间

